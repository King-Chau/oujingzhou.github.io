<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Redis学习路线 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Redis的优点高效Redis是纯内存数据库，采用了单线程模型和IO多路复用，使用了单个线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 丰富的数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 丰富的指令集合如可以设置key的过期时间等。 持久化">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习路线">
<meta property="og:url" content="http://example.com/2020/11/26/first-blog/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis的优点高效Redis是纯内存数据库，采用了单线程模型和IO多路复用，使用了单个线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。 丰富的数据类型Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。 丰富的指令集合如可以设置key的过期时间等。 持久化">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af992be51a946a581ea8a3e7bb6604c~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46a00b30444247d28ce656689a4f8a14~tplv-k3u1fbpfcp-zoom-1.image">
<meta property="article:published_time" content="2020-11-26T15:52:21.000Z">
<meta property="article:modified_time" content="2020-11-26T16:19:54.328Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af992be51a946a581ea8a3e7bb6604c~tplv-k3u1fbpfcp-zoom-1.image">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-first-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/11/26/first-blog/" class="article-date">
  <time datetime="2020-11-26T15:52:21.000Z" itemprop="datePublished">2020-11-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Redis学习路线
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis的优点"><a href="#Redis的优点" class="headerlink" title="Redis的优点"></a>Redis的优点</h1><h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>Redis是纯内存数据库，采用了单线程模型和IO多路复用，使用了单个线程来轮询描述符，将数据库的开、关、读、写都转换成了事件，减少了线程切换时上下文的切换和竞争。</p>
<h2 id="丰富的数据类型"><a href="#丰富的数据类型" class="headerlink" title="丰富的数据类型"></a>丰富的数据类型</h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p>
<h2 id="丰富的指令集合"><a href="#丰富的指令集合" class="headerlink" title="丰富的指令集合"></a>丰富的指令集合</h2><p>如可以设置key的过期时间等。</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>由于Redis是纯内存数据库，如果没有配置持久化，内存中的数据会丢失，于是需要开启Redis的持久化功能，将数据刷新到磁盘上。当redis重启后，可以从磁盘中恢复数据。Redis提供两种方式进行持久化，RDB持久化（将内存快照dump到磁盘上生成RDB文件），另外一种是AOF（append only file）持久化（将Reids的操作日志以追加的方式写入AOF文件）。</p>
<h2 id="支持多种部署架构"><a href="#支持多种部署架构" class="headerlink" title="支持多种部署架构"></a>支持多种部署架构</h2><p>主从架构，哨兵模式，集群架构等。</p>
<h1 id="Redis的应用场景"><a href="#Redis的应用场景" class="headerlink" title="Redis的应用场景"></a>Redis的应用场景</h1><h2 id="热点数据缓存"><a href="#热点数据缓存" class="headerlink" title="热点数据缓存"></a>热点数据缓存</h2><p>由于Redis访问速度极快（每秒10w），所以很适合用来缓存热点数据，另外结合expire功能，可以设置缓存的失效时间。</p>
<h2 id="限时"><a href="#限时" class="headerlink" title="限时"></a>限时</h2><p>利用Redis的expire命令可以设置key的失效时间，从而可以实现限时优惠活动，手机验证码等业务场景。</p>
<h2 id="分布式计数器"><a href="#分布式计数器" class="headerlink" title="分布式计数器"></a>分布式计数器</h2><p>利用Redis的incrby命令可以实现原子性的递增，从而可以实现高并发的秒杀活动的计数，分布式ID的生成等。</p>
<h2 id="排行榜问题"><a href="#排行榜问题" class="headerlink" title="排行榜问题"></a>排行榜问题</h2><p>利用Redis的有序集合（zset）可以实现热点数据的排行榜。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>利用Redis的setnx（set if not exist）命令结合超时功能，可以实现分布式锁。</p>
<h2 id="延时操作"><a href="#延时操作" class="headerlink" title="延时操作"></a>延时操作</h2><p>在订单产生后就占用了库存，10分钟后去检验用户是否真的付款购买，如果没有购买，则还原库存。</p>
<h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><p>Redis的队列可以设置为阻塞队列（brpush, brpop），从而可以实现简单的消息队列中间件。</p>
<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><p>Redis五种数据类型的底层实现方式：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/caishenfans/article/details/44784131">https://blog.csdn.net/caishenfans/article/details/44784131</a></p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>Redis最基本的数据类型，每个value最大能存储512mb，常用命令为get/set key value，用作计数器时，value的值必须能转换成整数或浮点数，否则在进行加减操作时会报错。</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  HMSET book name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;  HGETALL book</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;redis basic commands for caching&quot;</span><br><span class="line">5) &quot;likes&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;visitors&quot;</span><br><span class="line">8) &quot;23000&quot;</span><br></pre></td></tr></table></figure>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>String类型的列表，按照插入顺序排序，可以从列表头部或尾部添加/删除元素，可以存储 232 - 1 键值对（40多亿），支持一次性添加多个key。</p>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p>String类型的无序集合，集合成员是唯一的，添加，删除和查找的时间复杂度都是O(1)，支持一次性添加多个成员。</p>
<h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><p>有序集合，每个元素都会关联一个double类型的分数（score），可以通过score为集合中的成员从小到大排序，底层实现包括跳跃表或ziplist两种方式。</p>
<h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a>Bitmaps</h2><p>可以理解为只存储0/1的字符串，可以用来实现布隆过滤器解决缓存穿透的问题。</p>
<h2 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h2><p>用于存储地理位置信息（经纬度），并对存储的信息进行计算操作，如计算两个点之间的距离，计算当前点附近有哪些点等。</p>
<h1 id="持久化-1"><a href="#持久化-1" class="headerlink" title="持久化"></a>持久化</h1><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>在RDB持久化方式下，有两种选择，一种是手动执行持久化数据命令来让redis生成内存数据快照，另一种则是根据配置文件的策略，在满足条件时自动持久化数据。手动执行持久化有两个命令，save命令和bgsave命令。</p>
<p>save操作在Redis主线程中工作，因此会阻塞其他请求操作，应该避免使用。</p>
<p>bgsave则是fork出子进程，父进程继续处理请求。而子进程则将数据写入临时文件，并在写完后，替换原有的.rdb文件。fork发生时，父子进程内存共享，所以为了不影响子进程做数据快照，在这期间修改的数据，将会被复制一份，而不进行共享内存。所以说，RDB所持久化的数据，是fork发生时刻的数据。配置文件的策略：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line"></span><br><span class="line">save 300 10</span><br><span class="line"></span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>这是配置文件默认策略，三个策略是或的关系，即：</p>
<p>每隔900秒，在这期间变化了至少1个键值，做快照；</p>
<p>或每隔300秒，变化了10键值，做快照；</p>
<p>或每隔60秒，变化了至少10000个键值，做快照。</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>配置文件中的appendonly设置为yes。开启AOF持久化后，你所执行的每一条指令，都会以日志形式记录到appendonly.aof文件中。但事实上，aof文件并不会立即将命令写入到硬盘文件中，而是写入到硬盘缓存，可以在配置文件中配置多久把硬盘缓存写入到硬盘文件。所以在一定程度一定条件下，还是会有数据丢失，不过RDB方式相比可以大大减少数据损失。</p>
<p>redis默认使用everysec刷新磁盘缓存，就是说每秒持久化一次，而always则是每次操作都会立即写入aof文件中。而no则是不主动进行同步操作，是默认30s一次。当然always一定是效率最低的，个人认为everysec就够用了，数据安全性能又高。</p>
<p>AOF还支持日志重写，用来解决本地日志量过大的问题，如先后执行了set a a, set a b命令，重写之后只会记录set a b这一个操作，而del a操作就不再记录到日志等。</p>
<p>Redis也允许我们同时使用两种方式，重启redis后会优先从aof中恢复数据，毕竟aof比rdb损失的数据少，如果同时配置了RDB和AOF，启动只加载AOF文件恢复数据。如果只配置了RDB，启动时加载dump.rdb文件恢复数据。</p>
<h2 id="两种持久化方式的对比"><a href="#两种持久化方式的对比" class="headerlink" title="两种持久化方式的对比"></a>两种持久化方式的对比</h2><table>
<thead>
<tr>
<th>持久化方式</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>占用内存空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>存储速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>会丢失数据</td>
<td>依据策略决定</td>
</tr>
<tr>
<td>资源消耗</td>
<td>高，重量级</td>
<td>低，轻量级</td>
</tr>
<tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h1 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h1><p>如果在公司里落地生产环境用分布式锁的时候，一定是会用开源类库的，比如Redis分布式锁，一般就是用Redisson框架就好了，非常的简便易用。大家如果有兴趣，可以去看看Redisson的官网，看看如何在项目中引入Redisson的依赖，然后基于Redis实现分布式锁的加锁与释放锁。<br>下面给大家看一段简单的使用代码片段，先直观的感受一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rlock lock &#x3D; redisson.getLock(&quot;lock&quot;);</span><br><span class="line">lock.lock();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<p>此外，redisson还支持redis单实例、redis哨兵、redis cluster、redis master-slave等各种部署架构，都可以给你完美实现。</p>
<h2 id="Redisson实现Redis分布式锁的底层原理"><a href="#Redisson实现Redis分布式锁的底层原理" class="headerlink" title="Redisson实现Redis分布式锁的底层原理"></a>Redisson实现Redis分布式锁的底层原理</h2><p>好的，接下来就通过一张手绘图，给大家说说Redisson这个开源框架对Redis分布式锁的实现原理。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6af992be51a946a581ea8a3e7bb6604c~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。这里注意，仅仅只是选择一台机器！这点很关键！紧接着，就会发送一段lua脚本到redis上，那段lua脚本如下所示：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/46a00b30444247d28ce656689a4f8a14~tplv-k3u1fbpfcp-zoom-1.image" alt="avatar"></p>
<p>为啥要用lua脚本呢？因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。那么，这段lua脚本是什么意思呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">RLock lock &#x3D; redisson.getLock(&quot;myLock&quot;);</span><br></pre></td></tr></table></figure>
<p>这里你自己设置了加锁的那个锁key就是“myLock”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;ARGV[2]&#96;&#96;&#96;代表的是加锁的客户端的ID，类似于下面这样：</span><br></pre></td></tr></table></figure>
<p>8743c9c0-0795-4907-87fd-6c719a6b4586:1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给大家解释一下，第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。</span><br><span class="line">如何加锁呢？很简单，用下面的命令：</span><br></pre></td></tr></table></figure>
<p>hset myLock 8743c9c0-0795-4907-87fd-6c719a6b4586:1 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：</span><br></pre></td></tr></table></figure>
<p>myLock:<br>{<br>    “8743c9c0-0795-4907-87fd-6c719a6b4586:1” 1<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。</span><br><span class="line">接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。好了，到此为止，ok，加锁完成了。</span><br><span class="line"></span><br><span class="line">### 锁互斥机制</span><br><span class="line">那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含的是客户端1的ID。所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000毫秒的生存时间。此时客户端2会进入一个while循环，不停的尝试加锁。</span><br><span class="line">### watch dog自动延期机制</span><br><span class="line">客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</span><br><span class="line">### 可重入加锁机制</span><br><span class="line">那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？</span><br><span class="line">比如下面这种代码：</span><br></pre></td></tr></table></figure>
<p>RLock lock = redisson.getLock(“lock”);<br>lock.lock();<br>// biz<br>lock.lock();<br>// biz<br>lock.unlock();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这时我们来分析一下上面那段lua脚本。</span><br><span class="line">第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。</span><br><span class="line">第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”</span><br><span class="line">此时就会执行可重入加锁的逻辑，他会用：</span><br></pre></td></tr></table></figure>
<p>incrby myLock 8743c9c0-0795-4907-87fd-6c71a6b4586:1 1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过这个命令，对客户端1的加锁次数，累加1。此时myLock数据结构变为下面这样：</span><br></pre></td></tr></table></figure>
<p>myLock:<br>{<br>    “8743c9c0-0795-4907-87fd-6c719a6b4586:1” 2<br>}</p>
<p>```</p>
<p>大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数</p>
<h3 id="释放锁机制"><a href="#释放锁机制" class="headerlink" title="释放锁机制"></a>释放锁机制</h3><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：“del myLock”命令，从redis里删除这个key。然后呢，另外的客户端2就可以尝试完成加锁了。这就是所谓的分布式锁的开源Redisson框架的实现机制。一般我们在生产系统中，可以用Redisson框架提供的这个类库来基于redis进行分布式锁的加锁与释放锁。</p>
<h3 id="上述Redis分布式锁的缺点"><a href="#上述Redis分布式锁的缺点" class="headerlink" title="上述Redis分布式锁的缺点"></a>上述Redis分布式锁的缺点</h3><p>其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。此时就会导致多个客户端对一个分布式锁完成了加锁。这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：在redis master实例宕机的时候，可能导致多个客户端同时完成加锁。</p>
<p>参考： <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y_Uw3P2Ll7wvk_j5Fdlusw">https://mp.weixin.qq.com/s/y_Uw3P2Ll7wvk_j5Fdlusw</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/11/26/first-blog/" data-id="ckhz0y4480000lout3pva3qu5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/11/26/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/" rel="tag">redis</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/redis/" style="font-size: 10px;">redis</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/11/26/first-blog/">Redis学习路线</a>
          </li>
        
          <li>
            <a href="/2020/11/26/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>